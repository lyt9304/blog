---
title: 数据结构与算法之美 - 链表
date: 2018-10-22 12:34:01
categories:
  - 数据结构与算法之美
  - 数据结构与算法
  - 课程笔记
---

# 数据结构与算法之美 - 链表

> 所有内容均是来自极客时间王争老师的 [数据结构与算法之美](https://time.geekbang.org/column/126) 课程
> 文章只是摘要笔记

## 五花八门的链表结构

### 底层存储结构

- 数组：连续的内存空间
- 链表：通过指针将零碎的内存块串联

### 单链表

![single linked list](1.jpg)

- 头结点
- 尾结点：指针指向 NULL
- 单纯的指定插入删除，复杂度都是 O(1)
  ![](4.jpg)
- 随机访问第 k 个元素要从头开始，复杂度 O(n)

### 循环链表

![](2.jpg)

- 适合处理数据具有环形结构特点

> 约瑟夫问题
> 这个问题是以弗拉维奥·约瑟夫命名的，它是 1 世纪的一名犹太历史学家。他在自己的日记中写道，他和他的 40 个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。

### 双向链表

![](3.jpg)

- 某些情况下的插入、删除操作比单链要简单高效，但是空间消耗大，因为要多存一个前驱指针
- 删除
  - 删除结点中“值等于某个给定值”的结点；双向没有优势
  - 删除给定指针指向的结点；单向需要再找前驱的结点，还需要 O(n)；双向就不需要，还是 O(1)
- 插入，同理在指定指针前插入一个结点，双向链表更好
- 有序链表的查找，双向链表可以根据值得大小，向前找或向后找，平均只需要查找一半数据
- LinkedHashMap
- 空间换时间

### 双向循环链表

![](5.jpg)

## 数组与链表

### 复杂度

![](6.jpg)

### 内存

- 数组：内存连续，可以利用 CPU 缓存；大小固定，扩容成本高
- 链表：内存不连续，没有大小限制；额外指针消耗额外空间；频繁插入操作，会导致频繁内存申请和释放，容易造成内存碎片以及 GC

## 链表代码技巧

### 技巧一：理解指针或引用的含义

### 技巧二：警惕指针丢失和内存泄漏

### 技巧三：利用哨兵简化实现难度

- 原因：针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理
- 解决方法：引入哨兵结点（带头链表），这样就不需要做特殊情况的判断了
  ![](7.jpg)
- 其他应用：在 n 长度的数组中查找值为 val 的元素，可以将最后一个元素作为哨兵结点，赋值成 val，循环条件从 i < n 成为直接 arr[i] != val，从而减少了一次 i < n 的判断（即使 i < n，也还是需要判断 arr[i] == val）

### 技巧四：重点留意边界条件处理

- 链表为空时
- 链表只包含一个结点时
- 链表只包含两个结点时
- 代码逻辑处理头结点和尾结点

### 技巧五：举例画图，辅助思考

### 技巧六：多写多练，没有捷径

> leetcode 对应练习题：206，141，21，19，876

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

## 缓存

### 常用策略

- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

### LRU 的链表实现

- 维护有序链表缓存，头部更新，尾部更旧
- 新数据被访问，遍历链表
  - 已存在，从原位置删除，插入头部
  - 未存在
    - 缓存未满，插入头部
    - 缓存已满，删除最尾部，插入头部

## 思考题

### 回文判断

> 字符串使用单向链表存储，如何判断这个字符串是否是回文
