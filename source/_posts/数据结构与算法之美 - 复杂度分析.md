---
title: 数据结构与算法之美 - 复杂度分析
date: 2018-10-14 13:23:01
categories:
  - 数据结构与算法之美
  - 数据结构与算法
  - 课程笔记
---

# 数据结构与算法之美 - 复杂度分析

> 所有内容均是来自极客时间王争老师的 [数据结构与算法之美](https://time.geekbang.org/column/126) 课程
> 文章只是摘要笔记

## 1. 为什么需要复杂度分析

### 事后统计法

实实在在跑一遍得到执行时间和占用内存，其局限性：

- 结果非常依赖测试环境
- 结果受数据规模的影响很大

所以需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法

## 2. 时间复杂度分析

### 2.1 大 O 复杂度表示法

- 所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比
- 例子：`T(n) = O(2n+2)`
- 大 O 时间复杂度表示法，表示**代码执行时间随数据规模增长的变化趋势**，也叫作**渐进时间复杂度**，简称**时间复杂度**
- 当 n 很大时，公式中的低阶、常量、系数并不左右增长趋势，所以都可以忽略，即`T(n) = O(2n+2) = O(n)`

### 2.2 时间复杂度分析的法则

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 2.3 几种常见时间复杂度

![Tn](1.jpg)

- 多项式量级
  - `O(1)` 常量阶
    - 一般只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)
  - `O(logn)` 对数阶
    - 采用大 O 标记法时，O(log<sub>3</sub>n) = O(log<sub>3</sub>2 \* log<sub>2</sub>n) = O(log<sub>2</sub>n)，以什么为底其实不重要
  - `O(n)` 线性阶
  - `O(nlogn)` 线性对数阶
  - `O(n^2)` / `O(n^3)` ... 平方阶、立方阶、k 次方阶
  - `O(m+n)` m 和 n 表示两个数据规模，事先无法判断，所以这里不能使用加法法则
  - `O(m*n)`
- 非多项式量级 => NP 问题（Non-Deterministic Polynomial，非确定多项式） - `O(2^n)` 指数阶 - `O(n!)` 阶乘阶

### 2.4 空间复杂度分析

类比一下，空间复杂度全称就是**渐进空间复杂度**，表示**算法的存储空间与数据规模之间的增长关系**

## 3. 四个时间复杂度的维度

### 3.1 概念

- 最好情况时间复杂度（best case time complexity）
- 最坏情况时间复杂度（worst case time complexity）
- 平均情况时间复杂度（average case time complexity）
- 均摊时间复杂度（amortized time complexity）

### 3.2 最好、最坏情况时间复杂度

```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

- 最好情况：第一个就找到，然后退出，此时是 O(1)
- 最坏情况：数组中没有找到，遍历到了最后一个，此时是 O(n)
- 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度
- 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度

### 3.3 平均情况时间复杂度

- 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0 ～ n-1 位置中和不在数组中
- 在不在数组中概率 1/2，出现在任意位置的概率是 1/n
- 所以最终期望的计算为：O((3n+1)/4) = O(n)
  ![E](2.jpg)
- 这个值就是概率论中的**加权平均值**，也叫作**期望值**
- 平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**
- 一般使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分

### 3.4 均摊时间复杂度

```java
 // array 表示一个长度为 n 的数组
 // 代码中的 array.length 就等于 n
 int[] array = new int[n];
 int count = 0;

 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

这个例子大概的意思是，往这个数组插入数字，数组最大长度是定值 n，如果超过，则算出所有数字的和，放在 index 为 0 的位置，然后继续插入

- 按照之前的分析，每次插入，最好情况是数组没有满，则为 O(1)
- 最坏情况是数组满了，先要遍历 n 个数，计算出和，所以是 O(n)
- 根据概率论算出平均复杂度是 O(1)
- 这个例子中，有两个和之前不同的特点 - 一般情况都是复杂度低的，只有极端情况会变高 - 出现的情况是有规律的，在出入 n-1 次之后，必定会面临数组满了的情况
- 针对这种特例，可以用摊还分析法，得到均摊时间复杂度
- 每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)

## 其他阅读材料

- [拜托，面试别再问我时间复杂度了！！！](https://mp.weixin.qq.com/s/yfzrFYn0Dogy0HkN5XAS0Q)
